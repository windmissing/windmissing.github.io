---
layout: post
title:  "JAVA内存管理"
category: [从JAVA到C++]
tags: []
---

为了给JAVA开发人员准备讲C++的内存管理，顺便仔细阅读了《thinking in JAVA》中JAVA的内存管理。因为JAVA在内存管理方面做得比C++完善，使得许多JAVA的开发人员对内存管理很陌生。也正因为JAVA的内存管理做得更好更多，所以有更多的内存管理的内容需要解读。  
JAVA的内存管理主要是由JVM负责的。<thinking in JAVA>并没有非常深入细致地介绍，更多的内容还需要参考《JVM》。先把目前的理解记下来。  

<!-- more -->

#### JVM和平台无关性

和C++直接借助OS管理内存不同的是，JAVA通过JVM（JAVA虚拟机）间接地作用于操作系统。  
JVM正如其他虚拟机所做的工作一样，在操作系统的上做了一层铺垫，把上层应用与下层OS隔离开。上层应用不需要为不同的OS作适配，它只要适应JVM就可以了。适配OS的工作交给了JVM，不管底层OS是怎样的，只要向上提供的接口不变，上层应用就不用改变。  
JVM向上提供的是一种标准，这种标准不限制于JAVA。只要符合这种标准的可执行程序都可以在JVM上执行。  
JAVA也是一种编译型语言，但它的编译链接的过程与C++不同。JAVA是如何生成可执行程序的并不在本文的讨论范围中。  

#### 堆和栈

JAVA同样使用堆和栈两种内存分配方式。   
其中栈是程序运行时空间，用于管理程序调用时的产生的栈帧。通过栈顶指针的移动来表示分配或者回收空间。  
堆用于程序运行时动态的管理运行过程中产生的对象，包括对象的申请、释放、查询以及内存的分配、回收、查询。
通常情况下，栈的优点是速度快缺点是不灵活，而堆正好相反。JVM在这方面做了一些改进，使得在堆上的操作拥有接近栈的速度而不失本身的灵活性。  

#### 对象的分配

在JAVA中，开发人员只能申请对象，但对象如何分配开发人员无权干涉。（C++中开发人员通过代码自己决定如何申请对象）。  
而JAVA对于对象如何分配，却根据对象类别的不同做不同的处理，反而让人困惑。（有人会说，JAVA的对象都是在堆中的，并没有区别对待。我这里所谓的对象包括类类型的对象和基本类型的对象，我认为它们在使用中不应该有区别。）  

##### 基本类型

基本类型是指类似于int, char, boolean, byte、引用这样的类型。  
它的申请方式是这样的：`int a = 5;`  
a会以值的形式存储在栈中。  
因为存储在栈中，所以当调用另一个函数（切换栈帧）时原栈帧中的a就不可访问。  
因为是以值的形式存储，当执行`int b = a;`时在栈中又分配了一份空间，当执行`b = 6;`时a的值不对改变。当a以参数的形式传递给另一个函数时，传过去的只是与a相同值的另一个对象（类似于b），当另一个函数又修改了a的内容时原函数的a并没有改变。  

##### 类类型

类类型是指类似于`Interger`、数组、自定义类这样的类型。
它的申请方式是这样的：`A a = new A();`
a会以引用（C++中指针的概念）的形式存储在栈中，a所代表的对象存储在堆中。  
类类型的引用a与基本类型a在本质上是一样的，具有基本类型a的特点。  
a所代表的对象，因为存储在堆中，独立于栈帧之外，所以一但创建了，所有的函数都能访问它。
因为以引用的方式存储，当执行`A b = a;`时引用多了一份，对象没有改变。当执行`b.changeValue();`时a的对象的内容也被改变了。当a以参数的形式传递给另一个函数时，传过去的只是与a相同值的另一个引用，但它引用的对象与a是同一样，当另一个函数又修改了a的内容时原函数的a并没有改变，当另一个函数修改了a所引用对象的内容时，原函数a的对象的内容也改变了。  

#### 对象的释放

无论是基本类型还是类类型，无论是栈空间还是堆空间，所申请的对象都无须释放，因为GC机制会做好这一切。  
每个人都告诉我，JAVA的GC机制的原理是引用记数，即每增加一个引用就记数+1，释放一个引用就记数-1，减到0时GC就回收这个内存。  
具有讽刺意义的是，<thinking in JAVA>发现这种记数方法似乎从未被应用于任何一种JVM的实现中。也许只有阅读JVM的源码才能找到真相。但我更愿意相信<thinking in JAVA>的权威性。引用记数法统计内存，确实在python、swift等语言中有类似的应用，但JAVA不是。  

JVM提供两种内存清理模式：“标记-清扫”和“停止复制”，分别用于两种不同的场合。JVM分根据实际的内存分配情况自适应地选择一种模式进行清理。  

确定内存是否被占用的方法是一样的，从栈出发，用类似树遍历的方式，遍历所有的引用，最终能追溯到所有的对象。  
停止-复制是把一片内存的对象复制到另一片内存，复制的过程中就把被释放的空间略过去了。这种方法用于申请释放频繁、垃圾多、碎片多的情况。  
标记-清扫把被释放对象的空间回收，然后以紧凑的方式整理剩下的内存。这种方法用于程序运行已经稳定的情况。