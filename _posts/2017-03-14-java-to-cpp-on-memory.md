---
layout: post
title:  "从JAVA到C++（一） - 内存管理"
category: [从JAVA到C++]
tags: []
---

如[上文](http://windmissing.github.io/%E4%BB%8Ejava%E5%88%B0c++/2017-03/from-java-to-c-c++.html)所说，从JAVA到C++的转变并没有我们想象的那样简单，相反，由于JAVA一些先入为主的观念，反而会造成对C++理解上的一些困扰，因此，在学习C++的时候一定要先把JAVA暂时的忘掉。  
重要的事情说三遍。  
### forget
## forget
# FORGET

<!-- more -->

---

与JAVA对比，C++远没有那么方便，许多东西都是要开发者自己处理。所以在后面的课程中，基础语法都不会讲了，主要是介绍C++特有的那一部分。通过对这些内容的分析，发现大多数内容的根源在于内存管理。由于C++需要自己管理内存，才不得不多做很多额外的工作。理解好内存管理，是从JAVA到C++最重要的一步。今天第一节课，不讲代码，讲内存。  

#### 内存

我们所说的内存，不是电脑拔出来的那根内存条，而电脑在运行时里面的一片虚拟空间。  
为什么这么说，因为那根内存条代表的是物理内存，而我们要讲的是虚拟内存。  
如果你对大学时候的操作系统这门课还有印象，就会知道，物理内存的大小是由内存条决定的，所有进程共享的。虚拟内存的大小是由操作系统的位数决定的，而且每个进程独占同样大小的虚拟内存。  
比如32位的操作系统，每个进程独占4G的虚拟空间。现在我们都是64位了，虚拟空间有多大呢？我已经算不清楚了。  
64位系统的内存管理稍微复杂一点，我们这里就以32位系统为例。  

这样大的一个内存空间，进程是怎样为它的数据分配这些空间的？

1）栈区：由编译器自动分配和释放  
一般存放函数的参数值、局部变量的值等  
2）堆区：由程序员分配及释放。若程序员不释放，程序结束后可能由OS回收  
3）寄存器区：用来保存栈顶指针和指令指针  
4）全局区（静态区）：全局变量和静态变量是存储在一起的。初始化的和未初始化的是分开的。  
程序结束后由系统释放  
5）文字常量区：程序结束后由系统释放  
存放常量字符串  
6）程序代码区：存放函数体的二进制代码  

#### 堆和栈

其中与我们开发过程中关系最密切是的堆和栈。  
堆栈这两个字我们都非常熟悉，它们常常出现在数据结构中。这里的堆栈仅代表了内存中两片存放数据的区域，数据结构堆栈没有太多关系。  

我知道在JAVA里也有堆和栈的区分，但在写代码时并不考虑他们之间的区别，因此很多人不是非常清楚。  
1.JAVA堆栈和C++堆栈管理原理不同。本身双方的堆栈管理者就不同。C++自己并不管理堆栈，直接使用OS提供的接口来管理。JAVA的堆栈由JVM管理，JVM为了实现垃圾回收机制，以及解决堆效率等问题，在堆管理方面做了一些改进。在[JAVA内存管理]()有简单的说明，这里不做深入。  
2.JAVA堆栈与C++堆栈的实现效果类似。栈是程序运行时空间，由栈帧组成，由栈顶指针控制，分配和释放内存的效率高，但使用不灵活。堆用于动态地管理程序中的对象，使用灵活，但效率相对栈来说低一些。  
3.JAVA堆栈与C++堆栈的使用方式不同。JAVA仅使用栈做程序运行以及简单类型的存放，所有的对象都放在堆中的管理。C++的堆和栈都可以用于存放对象，以哪种方式管理对象取决于开发人员的代码。（重要）

#### 地址、指针、引用和值

在C++中，不管理是内置类型还是类类型，不管是堆中对象还是栈中对象，都包含两个属性：地址和值。也可以为这个对象定义两个属性：指针和引用。  
内置类型对应的变量也可以看做是对象，与类类型的对象没有太大区别。包括指针本身，它也有它的地址和值。

```c++
#include<iostream>
using namespace std;

int main()
{
    int n = 0; //值
    int *p = n; //指针
    int &rn = n; //引用
    
    cout<<n<<' '<<&n<<endl; //n的值和地址
    cout<<p<<' '<<&p<<' '<<*p<<endl; //p的值、地址和指向的地址的值
    cout<<rn<<' '<<&rn<<endl; //rn的值和地址
}
```

```c++
#include<iostream>
using namespace std;

class A
{};

int main()
{
    int n = 0; //栈中分配的内置类型
    int *pn = new int(); //堆中分配的内置类型
    int &rn = n;
    A a; //栈中分配的类类型
    A *pa = new A(); //堆中分配的类类型
    A &ra = *pa;
    
    cout<<n<<' '<<&n<<endl;
    cout<<*pn<<' '<<pn<<endl;
    cout<<&a<<endl;
    cout<<pa<<endl;
    cout<<pn<<' '<<&pn<<endl;
    cout<<pa<<' '<<&pa<<endl;
    cout<<rn<<' '<<&rn<<endl;
    cout<<ra<<' '<<&ra<<endl;
    return 0;
}
```

此处应当有图。  

